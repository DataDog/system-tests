name: Testing the test
on:
  workflow_dispatch: {}
  schedule:
  - cron: 00 02 * * 2-6

  pull_request:
    branches:
    - '**'
    types:
    - opened
    - synchronize
    - labeled
    - unlabeled

  push:
    branches:
    - main

env:
  REGISTRY: ghcr.io
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:

  lint:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout
      uses: actions/checkout@v3
    - name: Run lints
      uses: ./.github/actions/lint_code

  test_the_test:
    strategy:
      matrix:
        os:
          - macos-latest
          - ubuntu-latest
    name: Test the test (${{ matrix.os }})
    runs-on: ${{ matrix.os }}
    steps:
      - name: Checkout
        uses: actions/checkout@v3
      - name: Install runner
        uses: ./.github/actions/install_runner
      # force /bin/bash in order to test against bash 3.2 on macOS
      - name: Test the test (direct)
        run: /bin/bash run.sh TEST_THE_TEST
      - name: Test group parsing
        run: |
          /bin/bash run.sh ++dry APPSEC_SCENARIOS
          /bin/bash run.sh ++dry TRACER_RELEASE_SCENARIOS

  scenarios:
    uses: datadog/system-tests/.github/workflows/compute-scenarios.yml@main

  parametric:
    if: needs.scenarios.outputs.run_parametric == 'true'
    needs:
    - lint
    - test_the_test
    - scenarios
    uses: datadog/system-tests/.github/workflows/parametric.yml@main
    secrets: inherit

  experimental:
    if: needs.scenarios.outputs.run_libinjection == 'true'
    needs:
    - lint
    - test_the_test
    - scenarios
    uses: datadog/system-tests/.github/workflows/experimental.yml@main
    secrets: inherit

  main:
    if: ${{ false }}  # disable for now
    runs-on: ubuntu-latest
    needs:
    - lint
    - test_the_test
    - scenarios
    strategy:
      matrix:
        variant:
        - library: cpp
          weblog: nginx
        - library: dotnet
          weblog: poc
        - library: dotnet
          weblog: uds
        - library: golang
          weblog: chi
        - library: golang
          weblog: echo
        - library: golang
          weblog: gin
        - library: golang
          weblog: net-http
        - library: golang
          weblog: uds-echo
        - library: java
          weblog: jersey-grizzly2
        - library: java
          weblog: ratpack
        - library: java
          weblog: resteasy-netty3
        - library: java
          weblog: vertx3
        - library: java
          weblog: vertx4
        - library: java
          weblog: spring-boot-jetty
        - library: java
          weblog: spring-boot
        - library: java
          weblog: spring-boot-3-native
        - library: java
          weblog: uds-spring-boot
        - library: java
          weblog: spring-boot-openliberty
        - library: java
          weblog: spring-boot-wildfly
        - library: java
          weblog: spring-boot-undertow
        - library: java
          weblog: spring-boot-payara
        - library: java
          weblog: akka-http
        - library: java
          weblog: play
        - library: nodejs
          weblog: express4
        - library: nodejs
          weblog: uds-express4
        - library: nodejs
          weblog: express4-typescript
        - library: nodejs
          weblog: nextjs
        - library: php
          weblog: apache-mod-7.0
        - library: php
          weblog: apache-mod-7.1
        - library: php
          weblog: apache-mod-7.2
        - library: php
          weblog: apache-mod-7.3
        - library: php
          weblog: apache-mod-7.4
        - library: php
          weblog: apache-mod-8.0
        - library: php
          weblog: apache-mod-8.1
        - library: php
          weblog: apache-mod-8.2
        - library: php
          weblog: apache-mod-7.0-zts
        - library: php
          weblog: apache-mod-7.1-zts
        - library: php
          weblog: apache-mod-7.2-zts
        - library: php
          weblog: apache-mod-7.3-zts
        - library: php
          weblog: apache-mod-7.4-zts
        - library: php
          weblog: apache-mod-8.0-zts
        - library: php
          weblog: apache-mod-8.1-zts
        - library: php
          weblog: apache-mod-8.2-zts
        - library: php
          weblog: php-fpm-7.0
        - library: php
          weblog: php-fpm-7.1
        - library: php
          weblog: php-fpm-7.2
        - library: php
          weblog: php-fpm-7.3
        - library: php
          weblog: php-fpm-7.4
        - library: php
          weblog: php-fpm-8.0
        - library: php
          weblog: php-fpm-8.1
        - library: php
          weblog: php-fpm-8.2
        - library: python
          weblog: flask-poc
        - library: python
          weblog: django-poc
        - library: python
          weblog: uwsgi-poc
        - library: python
          weblog: uds-flask
        - library: python
          weblog: python3.12
        - library: python
          weblog: fastapi
        - library: ruby
          weblog: rack
        - library: ruby
          weblog: sinatra14
        - library: ruby
          weblog: sinatra20
        - library: ruby
          weblog: sinatra21
        - library: ruby
          weblog: uds-sinatra
        - library: ruby
          weblog: rails32
        - library: ruby
          weblog: rails40
        - library: ruby
          weblog: rails41
        - library: ruby
          weblog: rails42
        - library: ruby
          weblog: rails50
        - library: ruby
          weblog: rails51
        - library: ruby
          weblog: rails52
        - library: ruby
          weblog: rails60
        - library: ruby
          weblog: rails61
        - library: ruby
          weblog: rails70
        version:
        - prod
        - dev
            
      fail-fast: false
    env:
      TEST_LIBRARY: ${{ matrix.variant.library }}
      WEBLOG_VARIANT: ${{ matrix.variant.weblog }}
    steps:
    - name: Checkout
      uses: actions/checkout@v3
    - name: Install runner
      uses: ./.github/actions/install_runner
    - name: Pull images
      uses: ./.github/actions/pull_images
      with:
        pull-all: ${{ needs.scenarios.outputs.run_all == 'true' }}
    - name: Build python's weblog base images
      if: matrix.variant.library == 'python' && contains(github.event.pull_request.labels.*.name, 'build-python-base-images')
      run: |
        docker buildx build --load --progress=plain -f utils/build/docker/python/fastapi.base.Dockerfile -t datadog/system-tests:fastapi.base-v0 .
        docker buildx build --load --progress=plain -f utils/build/docker/python/python3.12.base.Dockerfile -t datadog/system-tests:python3.12.base-v0 .
        docker buildx build --load --progress=plain -f utils/build/docker/python/django-poc.base.Dockerfile -t datadog/system-tests:django-poc.base-v0 .
        docker buildx build --load --progress=plain -f utils/build/docker/python/flask-poc.base.Dockerfile -t datadog/system-tests:flask-poc.base-v2 .
        docker buildx build --load --progress=plain -f utils/build/docker/python/uwsgi-poc.base.Dockerfile -t datadog/system-tests:uwsgi-poc.base-v1 .
    - name: Build buddies weblog images
      if: contains(github.event.pull_request.labels.*.name, 'build-buddies-images')
      run: ./utils/build/build_tracer_buddies.sh
    - name: Build proxy image
      if: contains(github.event.pull_request.labels.*.name, 'build-proxy-image')
      run: ./build.sh -i proxy
    #### appsec-event-rules is now a private repo. The GH_TOKEN provided can't read private repos.
    #### skipping this, waiting for a proper solution
    # - name: Load WAF rules
    #   if: ${{ matrix.version == 'dev' }}
    #   run: ./utils/scripts/load-binary.sh waf_rule_set
    #   env:
    #     GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    - name: Load library binary
      if: ${{ matrix.version == 'dev' }}
      run: ./utils/scripts/load-binary.sh ${{ matrix.variant.library }}

    - name: Load library PHP appsec binary
      if: ${{ matrix.variant.library == 'php' }}
      run: ./utils/scripts/load-binary.sh php_appsec ${{matrix.version}}
    - name: Load agent binary
      if: ${{ matrix.version == 'dev' }}
      run: ./utils/scripts/load-binary.sh agent
    - name: Log in to the Container registry
      if: ${{ matrix.variant.library == 'ruby' }}
      run: echo ${{ secrets.GITHUB_TOKEN }} | docker login ${{ env.REGISTRY }} -u ${{ github.actor }} --password-stdin
    - name: Build agent
      run: SYSTEM_TEST_BUILD_ATTEMPTS=3 ./build.sh -i agent
    - name: Build weblog
      id: build
      run: SYSTEM_TEST_BUILD_ATTEMPTS=3 ./build.sh -i weblog
    - name: Run DEFAULT scenario
      if: steps.build.outcome == 'success'
      run: ./run.sh DEFAULT
      env:
        DD_API_KEY: ${{ secrets.DD_API_KEY }}
    - name: Run CROSSED_TRACING_LIBRARIES scenario
      if: always() && steps.build.outcome == 'success' && needs.scenarios.outputs.run_integration == 'true'
      run: ./run.sh CROSSED_TRACING_LIBRARIES
      env:
        DD_API_KEY: ${{ secrets.DD_API_KEY }}
    - name: Run PROFILING scenario
      if: always() && steps.build.outcome == 'success' && needs.scenarios.outputs.run_profiling == 'true'
      run: ./run.sh PROFILING
      env:
        DD_API_KEY: ${{ secrets.DD_API_KEY }}
    - name: Run TRACE_PROPAGATION_STYLE_W3C scenario
      if: always() && steps.build.outcome == 'success' && matrix.variant.library != 'python' && needs.scenarios.outputs.run_all == 'true'
      run: ./run.sh TRACE_PROPAGATION_STYLE_W3C
      env:
        DD_API_KEY: ${{ secrets.DD_API_KEY }}
    - name: Run INTEGRATIONS scenario
      if: always() && steps.build.outcome == 'success' && needs.scenarios.outputs.run_integration == 'true'
      run: ./run.sh INTEGRATIONS
      env:
        DD_API_KEY: ${{ secrets.DD_API_KEY }}
    - name: Run APM_TRACING_E2E_OTEL scenario
      if: always() && steps.build.outcome == 'success' && needs.scenarios.outputs.run_open_telemetry == 'true'
      run: ./run.sh APM_TRACING_E2E_OTEL
      env:
        DD_API_KEY: ${{ secrets.DD_API_KEY }}
        DD_APPLICATION_KEY: ${{ secrets.DD_APPLICATION_KEY }}
        DD_APP_KEY: ${{ secrets.DD_APPLICATION_KEY }}
    - name: Run LIBRARY_CONF_CUSTOM_HEADER_TAGS scenario
      if: always() && steps.build.outcome == 'success' && needs.scenarios.outputs.run_all == 'true'
      run: ./run.sh LIBRARY_CONF_CUSTOM_HEADER_TAGS
      env:
        DD_API_KEY: ${{ secrets.DD_API_KEY }}
    - name: Run LIBRARY_CONF_CUSTOM_HEADER_TAGS_INVALID scenario
      if: always() && steps.build.outcome == 'success' && needs.scenarios.outputs.run_all == 'true'
      run: ./run.sh LIBRARY_CONF_CUSTOM_HEADER_TAGS_INVALID
      env:
        DD_API_KEY: ${{ secrets.DD_API_KEY }}
    - name: Run REMOTE_CONFIG_MOCKED_BACKEND_ASM_FEATURES scenario
      if: always() && steps.build.outcome == 'success' && needs.scenarios.outputs.run_all == 'true'
      run: ./run.sh REMOTE_CONFIG_MOCKED_BACKEND_ASM_FEATURES
      env:
        DD_API_KEY: ${{ secrets.DD_API_KEY }}
    - name: Run REMOTE_CONFIG_MOCKED_BACKEND_LIVE_DEBUGGING scenario
      if: always() && steps.build.outcome == 'success' && needs.scenarios.outputs.run_all == 'true'
      run: ./run.sh REMOTE_CONFIG_MOCKED_BACKEND_LIVE_DEBUGGING
      env:
        DD_API_KEY: ${{ secrets.DD_API_KEY }}
    - name: Run REMOTE_CONFIG_MOCKED_BACKEND_ASM_DD scenario
      if: always() && steps.build.outcome == 'success' && needs.scenarios.outputs.run_all == 'true'
      run: ./run.sh REMOTE_CONFIG_MOCKED_BACKEND_ASM_DD
      env:
        DD_API_KEY: ${{ secrets.DD_API_KEY }}
    - name: Run REMOTE_CONFIG_MOCKED_BACKEND_ASM_FEATURES_NOCACHE scenario
      if: always() && steps.build.outcome == 'success' && needs.scenarios.outputs.run_all == 'true'
      run: ./run.sh REMOTE_CONFIG_MOCKED_BACKEND_ASM_FEATURES_NOCACHE
      env:
        DD_API_KEY: ${{ secrets.DD_API_KEY }}
    - name: Run REMOTE_CONFIG_MOCKED_BACKEND_LIVE_DEBUGGING_NOCACHE scenario
      if: always() && steps.build.outcome == 'success' && needs.scenarios.outputs.run_all == 'true'
      run: ./run.sh REMOTE_CONFIG_MOCKED_BACKEND_LIVE_DEBUGGING_NOCACHE
      env:
        DD_API_KEY: ${{ secrets.DD_API_KEY }}
    - name: Run REMOTE_CONFIG_MOCKED_BACKEND_ASM_DD_NOCACHE scenario
      if: always() && steps.build.outcome == 'success' && needs.scenarios.outputs.run_all == 'true'
      run: ./run.sh REMOTE_CONFIG_MOCKED_BACKEND_ASM_DD_NOCACHE
      env:
        DD_API_KEY: ${{ secrets.DD_API_KEY }}
    - name: Run APPSEC_MISSING_RULES scenario
      if: always() && steps.build.outcome == 'success' && needs.scenarios.outputs.run_appsec == 'true'
      run: ./run.sh APPSEC_MISSING_RULES
      env:
        DD_API_KEY: ${{ secrets.DD_API_KEY }}
    - name: Run APPSEC_CUSTOM_RULES scenario
      if: always() && steps.build.outcome == 'success' && needs.scenarios.outputs.run_appsec == 'true'
      run: ./run.sh APPSEC_CUSTOM_RULES
      env:
        DD_API_KEY: ${{ secrets.DD_API_KEY }}
    - name: Run APPSEC_CORRUPTED_RULES scenario
      if: always() && steps.build.outcome == 'success' && needs.scenarios.outputs.run_appsec == 'true'
      run: ./run.sh APPSEC_CORRUPTED_RULES
      env:
        DD_API_KEY: ${{ secrets.DD_API_KEY }}
    - name: Run APPSEC_RULES_MONITORING_WITH_ERRORS scenario
      if: always() && steps.build.outcome == 'success' && needs.scenarios.outputs.run_appsec == 'true'
      run: ./run.sh APPSEC_RULES_MONITORING_WITH_ERRORS
      env:
        DD_API_KEY: ${{ secrets.DD_API_KEY }}
    - name: Run APPSEC_BLOCKING scenario
      if: always() && steps.build.outcome == 'success' && needs.scenarios.outputs.run_appsec == 'true'
      run: ./run.sh APPSEC_BLOCKING
      env:
        DD_API_KEY: ${{ secrets.DD_API_KEY }}
    - name: Run APPSEC_DISABLED scenario
      if: always() && steps.build.outcome == 'success' && needs.scenarios.outputs.run_appsec == 'true'
      run: ./run.sh APPSEC_DISABLED
      env:
        DD_API_KEY: ${{ secrets.DD_API_KEY }}
    - name: Run APPSEC_LOW_WAF_TIMEOUT scenario
      if: always() && steps.build.outcome == 'success' && needs.scenarios.outputs.run_appsec == 'true'
      run: ./run.sh APPSEC_LOW_WAF_TIMEOUT
      env:
        DD_API_KEY: ${{ secrets.DD_API_KEY }}
    - name: Run APPSEC_CUSTOM_OBFUSCATION scenario
      if: always() && steps.build.outcome == 'success' && needs.scenarios.outputs.run_appsec == 'true'
      run: ./run.sh APPSEC_CUSTOM_OBFUSCATION
      env:
        DD_API_KEY: ${{ secrets.DD_API_KEY }}
    - name: Run APPSEC_RATE_LIMITER scenario
      if: always() && steps.build.outcome == 'success' && needs.scenarios.outputs.run_appsec == 'true'
      run: ./run.sh APPSEC_RATE_LIMITER
      env:
        DD_API_KEY: ${{ secrets.DD_API_KEY }}
    - name: Run APPSEC_BLOCKING_FULL_DENYLIST scenario
      if: always() && steps.build.outcome == 'success' && needs.scenarios.outputs.run_appsec == 'true'
      run: ./run.sh APPSEC_BLOCKING_FULL_DENYLIST
      env:
        DD_API_KEY: ${{ secrets.DD_API_KEY }}
    - name: Run APPSEC_REQUEST_BLOCKING scenario
      if: always() && steps.build.outcome == 'success' && needs.scenarios.outputs.run_appsec == 'true'
      run: ./run.sh APPSEC_REQUEST_BLOCKING
      env:
        DD_API_KEY: ${{ secrets.DD_API_KEY }}
    - name: Run APPSEC_RUNTIME_ACTIVATION scenario
      if: always() && steps.build.outcome == 'success' && needs.scenarios.outputs.run_appsec == 'true'
      run: ./run.sh APPSEC_RUNTIME_ACTIVATION
      env:
        DD_API_KEY: ${{ secrets.DD_API_KEY }}
    - name: Run APPSEC_WAF_TELEMETRY scenario
      if: always() && steps.build.outcome == 'success' && needs.scenarios.outputs.run_appsec == 'true'
      run: ./run.sh APPSEC_WAF_TELEMETRY
      env:
        DD_API_KEY: ${{ secrets.DD_API_KEY }}
    - name: Run APPSEC_API_SECURITY scenario
      if: always() && steps.build.outcome == 'success' && needs.scenarios.outputs.run_appsec == 'true'
      run: ./run.sh APPSEC_API_SECURITY
      env:
        DD_API_KEY: ${{ secrets.DD_API_KEY }}
    - name: Run APPSEC_AUTO_EVENTS_EXTENDED scenario
      if: always() && steps.build.outcome == 'success' && needs.scenarios.outputs.run_appsec == 'true'
      run: ./run.sh APPSEC_AUTO_EVENTS_EXTENDED
      env:
        DD_API_KEY: ${{ secrets.DD_API_KEY }}
    - name: Run SAMPLING scenario
      if: always() && steps.build.outcome == 'success' && needs.scenarios.outputs.run_sampling == 'true'
      run: ./run.sh SAMPLING
      env:
        DD_API_KEY: ${{ secrets.DD_API_KEY }}

    - name: Run TELEMETRY_APP_STARTED_PRODUCTS_DISABLED scenario
      if: always() && steps.build.outcome == 'success' && needs.scenarios.outputs.run_all == 'true'
      run: ./run.sh TELEMETRY_APP_STARTED_PRODUCTS_DISABLED
      env:
        DD_API_KEY: ${{ secrets.DD_API_KEY }}
    - name: Run TELEMETRY_LOG_GENERATION_DISABLED scenario
      if: always() && steps.build.outcome == 'success' && needs.scenarios.outputs.run_all == 'true'
      run: ./run.sh TELEMETRY_LOG_GENERATION_DISABLED
      env:
        DD_API_KEY: ${{ secrets.DD_API_KEY }}
    - name: Run TELEMETRY_METRIC_GENERATION_DISABLED scenario
      if: always() && steps.build.outcome == 'success' && needs.scenarios.outputs.run_all == 'true'
      run: ./run.sh TELEMETRY_METRIC_GENERATION_DISABLED
      env:
        DD_API_KEY: ${{ secrets.DD_API_KEY }}
    - name: Run TELEMETRY_METRIC_GENERATION_ENABLED scenario
      if: always() && steps.build.outcome == 'success' && needs.scenarios.outputs.run_all == 'true'
      run: ./run.sh TELEMETRY_METRIC_GENERATION_ENABLED
      env:
        DD_API_KEY: ${{ secrets.DD_API_KEY }}

    - name: Run TELEMETRY_DEPENDENCY_LOADED_TEST_FOR_DEPENDENCY_COLLECTION_DISABLED scenario
      if: always() && steps.build.outcome == 'success' && needs.scenarios.outputs.run_all == 'true'
      run: ./run.sh TELEMETRY_DEPENDENCY_LOADED_TEST_FOR_DEPENDENCY_COLLECTION_DISABLED
      env:
        DD_API_KEY: ${{ secrets.DD_API_KEY }}
    - name: Run DEBUGGER_PROBES_STATUS scenario
      if: always() && steps.build.outcome == 'success' && needs.scenarios.outputs.run_debugger == 'true'
      run: ./run.sh DEBUGGER_PROBES_STATUS
      env:
        DD_API_KEY: ${{ secrets.DD_API_KEY }}
    - name: Run DEBUGGER_METHOD_PROBES_SNAPSHOT scenario
      if: always() && steps.build.outcome == 'success' && needs.scenarios.outputs.run_debugger == 'true'
      run: ./run.sh DEBUGGER_METHOD_PROBES_SNAPSHOT
      env:
        DD_API_KEY: ${{ secrets.DD_API_KEY }}
    - name: Run DEBUGGER_LINE_PROBES_SNAPSHOT scenario
      if: always() && steps.build.outcome == 'success' && needs.scenarios.outputs.run_debugger == 'true'
      run: ./run.sh DEBUGGER_LINE_PROBES_SNAPSHOT
      env:
        DD_API_KEY: ${{ secrets.DD_API_KEY }}
    - name: Run DEBUGGER_MIX_LOG_PROBE scenario
      if: always() && steps.build.outcome == 'success' && needs.scenarios.outputs.run_debugger == 'true'
      run: ./run.sh DEBUGGER_MIX_LOG_PROBE
      env:
        DD_API_KEY: ${{ secrets.DD_API_KEY }}
    - name: Run all scenarios in replay mode
      if: always() && steps.build.outcome == 'success' && needs.scenarios.outputs.run_all == 'true'
      run: |
        ./run.sh DEFAULT --replay
        ./run.sh PROFILING --replay
        # ./run.sh TRACE_PROPAGATION_STYLE_W3C  # not working on python
        ./run.sh INTEGRATIONS --replay
        # ./run.sh APM_TRACING_E2E_OTEL --replay  # relies on backend
        ./run.sh LIBRARY_CONF_CUSTOM_HEADER_TAGS --replay
        ./run.sh LIBRARY_CONF_CUSTOM_HEADER_TAGS_INVALID --replay
        ./run.sh REMOTE_CONFIG_MOCKED_BACKEND_ASM_FEATURES --replay
        ./run.sh REMOTE_CONFIG_MOCKED_BACKEND_LIVE_DEBUGGING --replay
        ./run.sh REMOTE_CONFIG_MOCKED_BACKEND_ASM_DD --replay
        ./run.sh REMOTE_CONFIG_MOCKED_BACKEND_ASM_FEATURES_NOCACHE --replay
        ./run.sh REMOTE_CONFIG_MOCKED_BACKEND_LIVE_DEBUGGING_NOCACHE --replay
        ./run.sh REMOTE_CONFIG_MOCKED_BACKEND_ASM_DD_NOCACHE --replay
        ./run.sh APPSEC_MISSING_RULES --replay
        ./run.sh APPSEC_CUSTOM_RULES --replay
        ./run.sh APPSEC_CORRUPTED_RULES --replay
        ./run.sh APPSEC_RULES_MONITORING_WITH_ERRORS --replay
        ./run.sh APPSEC_BLOCKING --replay
        ./run.sh APPSEC_DISABLED --replay
        ./run.sh APPSEC_LOW_WAF_TIMEOUT --replay
        ./run.sh APPSEC_CUSTOM_OBFUSCATION --replay
        ./run.sh APPSEC_RATE_LIMITER --replay
        ./run.sh APPSEC_BLOCKING_FULL_DENYLIST --replay
        ./run.sh APPSEC_REQUEST_BLOCKING --replay
        ./run.sh APPSEC_RUNTIME_ACTIVATION --replay
        ./run.sh APPSEC_WAF_TELEMETRY --replay
        ./run.sh APPSEC_AUTO_EVENTS_EXTENDED --replay
        ./run.sh SAMPLING --replay
        ./run.sh TELEMETRY_DEPENDENCY_LOADED_TEST_FOR_DEPENDENCY_COLLECTION_DISABLED --replay
        ./run.sh DEBUGGER_PROBES_STATUS --replay
        ./run.sh DEBUGGER_METHOD_PROBES_SNAPSHOT --replay
        ./run.sh DEBUGGER_LINE_PROBES_SNAPSHOT --replay
        ./run.sh DEBUGGER_MIX_LOG_PROBE --replay
      env:
        DD_API_KEY: ${{ secrets.DD_API_KEY }}
        DD_APPLICATION_KEY: ${{ secrets.DD_APPLICATION_KEY }}
        DD_APP_KEY: ${{ secrets.DD_APPLICATION_KEY }}
    - name: Compress logs
      id: compress_logs
      if: always() && steps.build.outcome == 'success'
      run: tar -czvf artifact.tar.gz $(ls | grep logs)
    - name: Upload artifact
      if: always() && steps.compress_logs.outcome == 'success'
      uses: actions/upload-artifact@v3
      with:
        name: logs_${{ matrix.variant.library }}_${{ matrix.variant.weblog }}_${{ matrix.version }}_main
        path: artifact.tar.gz
    - name: Upload results CI Visibility
      if: ${{ always() }}
      run: ./utils/scripts/upload_results_CI_visibility.sh ${{ matrix.version }} system-tests ${{ github.run_id }}-${{ github.run_attempt }}
      env:
        DD_API_KEY: ${{ secrets.DD_CI_API_KEY }}
    - name: Print fancy log report
      if: ${{ always() }}
      run: python utils/scripts/markdown_logs.py >> $GITHUB_STEP_SUMMARY

  open-telemetry-manual:
    runs-on: ubuntu-latest
    if: needs.scenarios.outputs.run_open_telemetry == 'true'
    needs:
    - lint
    - test_the_test
    - scenarios
    steps:
    - name: Checkout
      uses: actions/checkout@v3
    - name: Install runner
      uses: ./.github/actions/install_runner
    - name: Pull mitmproxy image
      run: docker pull datadog/system-tests:proxy-v1 || true
    - name: Build proxy image
      if: contains(github.event.pull_request.labels.*.name, 'build-proxy-image')
      run: ./build.sh -i proxy
    - name: Build agent
      run: SYSTEM_TEST_BUILD_ATTEMPTS=3 ./build.sh java_otel -i agent
    - name: Build weblog
      id: build
      run: SYSTEM_TEST_BUILD_ATTEMPTS=3 ./build.sh java_otel -i weblog
    - name: Run OTEL_TRACING_E2E scenario
      if: always() && steps.build.outcome == 'success'
      run: ./run.sh OTEL_TRACING_E2E
      env:
        DD_API_KEY: ${{ secrets.DD_API_KEY }}
        DD_APPLICATION_KEY: ${{ secrets.DD_APPLICATION_KEY }}
        DD_APP_KEY: ${{ secrets.DD_APPLICATION_KEY }}
        DD_API_KEY_2: ${{ secrets.DD_API_KEY_2 }}
        DD_APP_KEY_2: ${{ secrets.DD_APP_KEY_2 }}
        DD_API_KEY_3: ${{ secrets.DD_API_KEY_3 }}
        DD_APP_KEY_3: ${{ secrets.DD_APP_KEY_3 }}
    - name: Run OTEL_METRIC_E2E scenario
      if: always() && steps.build.outcome == 'success'
      run: ./run.sh OTEL_METRIC_E2E
      env:
        DD_API_KEY: ${{ secrets.DD_API_KEY }}
        DD_APPLICATION_KEY: ${{ secrets.DD_APPLICATION_KEY }}
        DD_APP_KEY: ${{ secrets.DD_APPLICATION_KEY }}
        DD_API_KEY_2: ${{ secrets.DD_API_KEY_2 }}
        DD_APP_KEY_2: ${{ secrets.DD_APP_KEY_2 }}
        DD_API_KEY_3: ${{ secrets.DD_API_KEY_3 }}
        DD_APP_KEY_3: ${{ secrets.DD_APP_KEY_3 }}
    - name: Run OTEL_LOG_E2E scenario
      if: always() && steps.build.outcome == 'success'
      run: ./run.sh OTEL_LOG_E2E
      env:
        DD_API_KEY: ${{ secrets.DD_API_KEY }}
        DD_APPLICATION_KEY: ${{ secrets.DD_APPLICATION_KEY }}
        DD_APP_KEY: ${{ secrets.DD_APPLICATION_KEY }}
        DD_API_KEY_2: ${{ secrets.DD_API_KEY_2 }}
        DD_APP_KEY_2: ${{ secrets.DD_APP_KEY_2 }}
        DD_API_KEY_3: ${{ secrets.DD_API_KEY_3 }}
        DD_APP_KEY_3: ${{ secrets.DD_APP_KEY_3 }}

    - name: Compress logs
      if: always() && steps.build.outcome == 'success'
      run: tar -czvf artifact.tar.gz $(ls | grep logs)
    - name: Upload artifact
      if: always() && steps.build.outcome == 'success'
      uses: actions/upload-artifact@v3
      with:
        name: logs_java-otel_prod
        path: artifact.tar.gz

  open-telemetry-automatic:
    if: ${{ false }}  
    runs-on: ubuntu-latest
    #if: needs.scenarios.outputs.run_open_telemetry == 'true' || needs.scenarios.outputs.run_integration == 'true'
    needs:
    - lint
    - test_the_test
    - scenarios
    strategy:
      matrix:
        variant:
        - library: java_otel
          weblog: spring-boot-otel
        - library: python_otel
          weblog: flask-poc-otel
        - library: nodejs_otel
          weblog: express4-otel
        version:
        - prod        
      fail-fast: false
    env:
      TEST_LIBRARY: ${{ matrix.variant.library }}
      WEBLOG_VARIANT: ${{ matrix.variant.weblog }}
    steps:
    - name: Checkout
      uses: actions/checkout@v3
    - name: Install runner
      uses: ./.github/actions/install_runner
    - name: Pull mitmproxy image
      run: docker pull datadog/system-tests:proxy-v1 || true
    - name: Build proxy image
      if: contains(github.event.pull_request.labels.*.name, 'build-proxy-image')
      run: ./build.sh -i proxy
    - name: Build agent
      run: SYSTEM_TEST_BUILD_ATTEMPTS=3 ./build.sh ${{ matrix.variant.library }} -i agent

    - name: Build weblog opentelemetry autoinstrumentation
      if: always() 
      id: build_otel
      run: SYSTEM_TEST_BUILD_ATTEMPTS=3 ./build.sh ${{ matrix.variant.library }} --weblog-variant ${{ matrix.variant.weblog }}
    - name: Run OTEL_INTEGRATIONS scenario
      if: always() && steps.build_otel.outcome == 'success'
      run: ./run.sh OTEL_INTEGRATIONS
      env:
        DD_API_KEY: ${{ secrets.DD_API_KEY }}
        DD_APPLICATION_KEY: ${{ secrets.DD_APPLICATION_KEY }}
        DD_APP_KEY: ${{ secrets.DD_APPLICATION_KEY }}
    - name: Compress logs
      if: always() && steps.build_otel.outcome == 'success'
      run: tar -czvf artifact.tar.gz $(ls | grep logs)
    - name: Upload artifact
      if: always() && steps.build_otel.outcome == 'success'
      uses: actions/upload-artifact@v3
      with:
        name: logs_${{ matrix.variant.library }}_${{ matrix.variant.version }}
        path: artifact.tar.gz

  update-CI-visibility:
    runs-on: ubuntu-latest
    needs:
    - main
    if: always() && github.ref == 'refs/heads/main'
    steps:
    - name: Checkout
      uses: actions/checkout@v3
    - name: Update CI Dashboard
      run: ./utils/scripts/update_dashboard_CI_visibility.sh system-tests ${{ github.run_id }}-${{ github.run_attempt }}
      env:
        DD_API_KEY: ${{ secrets.DD_CI_API_KEY }}
        DD_APP_KEY: ${{ secrets.DD_CI_APP_KEY }}

  peformances:
    runs-on: ubuntu-latest
    if: needs.scenarios.outputs.run_all == 'true'
    needs:
    - lint
    - test_the_test
    - scenarios
    env:
      DD_API_KEY: ${{ secrets.DD_API_KEY }}
    steps:
    - name: Checkout
      uses: actions/checkout@v3
    - name: Setup python 3.9
      uses: actions/setup-python@v4
      with:
        python-version: '3.9'
    - name: Run
      run: ./tests/perfs/run.sh golang
    - name: Display
      run: |
        source venv/bin/activate
        python tests/perfs/process.py

  fuzzer:
    runs-on: ubuntu-latest
    if: needs.scenarios.outputs.run_all == 'true'
    needs:
    - lint
    - test_the_test
    - scenarios
    env:
      DD_API_KEY: ${{ secrets.DD_API_KEY }}
    steps:
    - name: Checkout
      uses: actions/checkout@v3
    - name: Install runner
      uses: ./.github/actions/install_runner
    - name: Build
      run: |
        ./build.sh -i agent
        ./build.sh golang -i weblog
    - name: Run
      run: ./tests/fuzzer/run.sh
