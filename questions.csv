question,category,answer
"what should i do to create a new end to end weblog for nodejs using fastify.",end-to-end,"The Fastify weblog already exists for Node.js in system-tests! You can find it at utils/build/docker/nodejs/fastify.Dockerfile. It has many endpoints already implemented. To work with it: 1. Build it: ./build.sh nodejs -w fastify (note: language parameter is mandatory!) 2. Check existing endpoints: Review the ""Endpoints"" section in docs/weblog/README.md to see which endpoints are available 3. If you want to add new endpoints: Implement missing endpoints from the standard list documented in docs/weblog/README.md 4. Test it: Run with ./run.sh <SCENARIO_NAME> where the scenario supports Node.js weblogs. If you want to create a completely NEW weblog variant (not Fastify), you would need to: Create a new Dockerfile in utils/build/docker/nodejs/, Include at least the /healthcheck endpoint, Add one example endpoint, Document it in docs/execute/build.md, Update compatibility in utils/scripts/ci_orchestrators/workflow_data.py"
"what end to end scenarios include the endpoint /shell_execution? Always include the scenario name in your answer.",end-to-end,"The /shell_execution endpoint is used in the DEFAULT scenario. You can find it in the test file tests/appsec/iast/source/test_shell_execution.py. This test class (Test_ShellExecution) doesn't have an explicit @scenarios decorator, which means it runs only in the DEFAULT scenario. The test validates shell injection vulnerability detection through the IAST (Interactive Application Security Testing) functionality."
"what should i do to create a new scenario with name ""not_sure_scenario""",end-to-end,"Before creating a new scenario, I need to know what type of scenario you want to create. There are several main types in system-tests: 1. End-to-End - Tests the full integration between weblog, library, agent, and backend 2. Parametric - Tests library behavior through a parametric API 3. SSI (Single Step Instrumentation) - Includes AWS SSI, Docker SSI for auto-injection testing 4. Kubernetes (K8s) - Tests library injection in Kubernetes environments. Each type has different requirements, documentation, and setup steps. Could you clarify which type of scenario you need? For example: What will ""not_sure_scenario"" test? Does it need special environment variables? Does it require specific weblog/agent/backend configurations? Once I know the type, I can guide you through the specific steps!"
"what should i do to create a new end-to-end scenario called ""my_new_appsec_scenario"" that populates these env variables into the weblog: ""DD_APPSEC_OBFUSCATION_PARAMETER_KEY_REGEXP"": ""hide-key"", ""DD_APPSEC_OBFUSCATION_PARAMETER_VALUE_REGEXP"": "".*hide_value"". Could i use an existing scenario with similar configurations?",end-to-end,"Great news! You can use an existing scenario instead of creating a new one! The scenario APPSEC_CUSTOM_OBFUSCATION already exists and has similar configurations for obfuscation testing. However, if the existing scenario doesn't exactly match your requirements, you can create a new scenario: 1. Define the scenario in utils/_context/_scenarios/__init__.py 2. Annotate your test classes with @scenarios.my_new_appsec_scenario 3. Run it: ./run.sh MY_NEW_APPSEC_SCENARIO. But I strongly recommend checking the existing APPSEC_CUSTOM_OBFUSCATION scenario first to avoid duplication!"
"What should i do to create a new test case for the new scenario ""my_new_appsec_scenario"" that perform a request to /waf endpoint (security attack simulation) with header that it's key it should be obfuscated. validate in the library interface that key doesn't appear in the appsec data/messages",end-to-end,"Create the test file in tests/appsec/ directory. The test should: 1. Use @scenarios.my_new_appsec_scenario decorator (or @scenarios.appsec_custom_obfuscation if using existing) 2. In setup_obfuscated_header_attack method: make a request using self.response = weblog.get(""/waf"", headers={""hide-key"": ""attack-value""}) 3. In test_obfuscated_header_attack method: use assert_waf_attack(self.response) to validate WAF detected the attack, then get traces with interfaces.library.get_traces(request=self.response), use nested_lookup to search for the obfuscated key, and assert the key doesn't appear in the data. Run the test with ./run.sh MY_NEW_APPSEC_SCENARIO. Key elements: assert_waf_attack() validates WAF detection, interfaces.library accesses intercepted messages, nested_lookup() searches for the key in data structure, store response in setup_ method for precise filtering."
