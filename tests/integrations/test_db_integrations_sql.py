# Unless explicitly stated otherwise all files in this repository are licensed under the the Apache License Version 2.0.
# This product includes software developed at Datadog (https://www.datadoghq.com/).
# Copyright 2021 Datadog, Inc.
import pytest
from utils import (
    context,
    sql_bug,
    missing_sql_feature,
    sql_irrelevant,
    manage_sql_decorators,
    bug,
    missing_feature,
    irrelevant,
    scenarios,
    flaky,
)
from utils.tools import logger
from utils import weblog, interfaces
from .sql_utils import BaseDbIntegrationsTestClass

# Define the data for test case generation
test_sql_operations = ["select", "insert", "update", "delete", "procedure", "select_error"]
test_sql_services = ["mysql", "postgresql", "mssql"]

testdata_cache = {}


def pytest_generate_tests(metafunc):
    """ Generate parametrized tests for given sql_operations (basic sql operations; ie select,insert...) over sql_services (db services ie mysql,mssql...)"""

    if (
        "test_sql_service"
        and "test_sql_operation" in metafunc.fixturenames
        and context.scenario == scenarios.integrations_v3
    ):
        class_name = metafunc.cls.__name__.split("_")[1]
        if class_name not in testdata_cache:
            test_parameters = []
            test_ids = []
            for test_sql_service in test_sql_services:
                weblog.get("/db", params={"service": test_sql_service, "operation": "init"}, timeout=20)

                for test_sql_operation in test_sql_operations:
                    weblog_request = weblog.get(
                        "/db", params={"service": test_sql_service, "operation": test_sql_operation}
                    )
                    test_parameters.append((test_sql_service, test_sql_operation, weblog_request))
                    test_ids.append("db:" + test_sql_service + ",op:" + test_sql_operation)
            testdata_cache[class_name] = test_parameters
            testdata_cache[class_name + ".id"] = test_ids

        metafunc.parametrize(
            "test_sql_service,test_sql_operation,weblog_request",
            testdata_cache[class_name],
            ids=testdata_cache[class_name + ".id"],
        )


@scenarios.integrations_v3
class Test_DatadogDbIntegrationTestClass(BaseDbIntegrationsTestClass):
    """ Verify basic DB operations over different databases.
        Check integration spans status: https://docs.google.com/spreadsheets/d/1qm3B0tJ-gG11j_MHoEd9iMXf4_DvWAGCLwmBhWCxbA8/edit#gid=623219645 """

    def get_spans(self, request):
        """ get the spans from tracer and agent generated by request """

        # yield the span from the tracer in first, as if it fails, there is a good chance that the one from the agent also fails
        logger.debug("Validating span generated by Datadog library")
        yield self.get_span_from_tracer(request)

        logger.debug("Validating transmitted by Datadog agent")
        yield self.get_span_from_agent(request)

    # Tests methods
    def test_sql_traces(self, test_sql_service, test_sql_operation, weblog_request):
        """ After make the requests we check that we are producing sql traces """
        span_tracer, span_agent = self.get_spans(weblog_request)
        assert None not in [span_tracer, span_agent]

    @sql_irrelevant(
        condition=lambda test_sql_operation: test_sql_operation == "procedure" or test_sql_operation == "select_error",
        reason="Each db reports differently",
    )
    @pytest.mark.usefixtures("manage_sql_decorators")  # Mandatory for decorators to work :-(
    def test_resource(self, test_sql_service, test_sql_operation, weblog_request):
        """ Usually the query """
        span_tracer, span_agent = self.get_spans(weblog_request)
        assert all(
            test_sql_operation in span_resource
            for span_resource in [span_tracer["resource"].lower(), span_agent["resource"].lower()]
        )

    @sql_irrelevant(condition=lambda test_sql_operation: test_sql_operation == "select_error")
    @pytest.mark.usefixtures("manage_sql_decorators")
    def test_sql_success(self, test_sql_service, test_sql_operation, weblog_request):
        """ We check all sql launched for the app work """
        span_tracer, span_agent = self.get_spans(weblog_request)
        assert "error" not in span_tracer or span_tracer["error"] == 0
        assert "error" not in span_agent or span_agent["error"] == 0

    @irrelevant(library="python", reason="Python is using the correct span: db.system")
    @sql_bug(
        library="nodejs",
        condition=lambda test_sql_service: test_sql_service == "postgresql",
        reason="the value of this span should be 'postgresql' instead of  'postgres' ",
    )
    @pytest.mark.usefixtures("manage_sql_decorators")
    def test_db_type(self, test_sql_service, test_sql_operation, weblog_request):
        """ DEPRECATED!! Now it is db.system. An identifier for the database management system (DBMS) product being used.
            Must be one of the available values: https://datadoghq.atlassian.net/wiki/spaces/APM/pages/2357395856/Span+attributes#db.system """
        span_tracer, span_agent = self.get_spans(weblog_request)
        self._assert_span_meta(span_tracer, span_agent, "db.type", test_sql_service)

    @missing_sql_feature(
        library="python",
        condition=lambda test_sql_service: test_sql_service == "mssql",
        reason="Partial support for python and mssql",
    )
    @irrelevant(library="java", reason="Java is using the correct span: db.instance")
    @pytest.mark.usefixtures("manage_sql_decorators")
    def test_db_name(self, test_sql_service, test_sql_operation, weblog_request):
        """ DEPRECATED!! Now it is db.instance. The name of the database being connected to. Database instance name."""
        db_container = context.scenario.get_container_by_dd_integration_name(test_sql_service)
        span_tracer, span_agent = self.get_spans(weblog_request)
        self._assert_span_meta(span_tracer, span_agent, "db.name", db_container.db_instance)

    def test_span_kind(self, test_sql_service, test_sql_operation, weblog_request):
        """ Describes the relationship between the Span, its parents, and its children in a Trace."""
        span_tracer, span_agent = self.get_spans(weblog_request)
        self._assert_span_meta(span_tracer, span_agent, "span.kind", "client")

    @missing_feature(library="python", reason="not implemented yet")
    @missing_feature(library="java", reason="not implemented yet")
    def test_runtime_id(self, test_sql_service, test_sql_operation, weblog_request):
        """ Unique identifier for the current process."""
        span_tracer, span_agent = self.get_spans(weblog_request)
        assert span_tracer["meta"]["runtime-id"].strip()
        assert span_agent["meta"]["runtime-id"].strip()

    @missing_feature(library="nodejs", reason="not implemented yet")
    @missing_feature(library="java", reason="not implemented yet")
    @missing_sql_feature(
        library="python",
        condition=lambda test_sql_service: test_sql_service == "mssql",
        reason="Partial support for python and mssql",
    )
    @pytest.mark.usefixtures("manage_sql_decorators")
    def test_db_system(self, test_sql_service, test_sql_operation, weblog_request):
        """ An identifier for the database management system (DBMS) product being used. Formerly db.type
                Must be one of the available values: https://datadoghq.atlassian.net/wiki/spaces/APM/pages/2357395856/Span+attributes#db.system """
        span_tracer, span_agent = self.get_spans(weblog_request)
        self._assert_span_meta(span_tracer, span_agent, "db.system", test_sql_service)

    @missing_feature(library="python", reason="not implemented yet")
    @missing_feature(library="nodejs", reason="not implemented yet")
    @missing_feature(library="java", reason="not implemented yet")
    def test_db_connection_string(self, test_sql_service, test_sql_operation, weblog_request):
        """ The connection string used to connect to the database. """
        span_tracer, span_agent = self.get_spans(weblog_request)
        assert span_tracer["meta"]["db.connection_string"].strip()
        assert span_agent["meta"]["db.connection_string"].strip()

    @missing_sql_feature(
        library="python",
        condition=lambda test_sql_service: test_sql_service == "mssql",
        reason="Partial support for python and mssql",
    )
    @pytest.mark.usefixtures("manage_sql_decorators")
    def test_db_user(self, test_sql_service, test_sql_operation, weblog_request):
        """ Username for accessing the database. """
        db_container = context.scenario.get_container_by_dd_integration_name(test_sql_service)
        span_tracer, span_agent = self.get_spans(weblog_request)
        self._assert_span_meta(span_tracer, span_agent, "db.user", db_container.db_user.casefold())

    @missing_feature(library="python", reason="not implemented yet")
    @missing_feature(library="nodejs", reason="not implemented yet")
    def test_db_instance(self, test_sql_service, test_sql_operation, weblog_request):
        """ The name of the database being connected to. Database instance name. Formerly db.name"""
        db_container = context.scenario.get_container_by_dd_integration_name(test_sql_service)
        span_tracer, span_agent = self.get_spans(weblog_request)
        self._assert_span_meta(span_tracer, span_agent, "db.instance", db_container.db_instance)

    @missing_feature(library="python", reason="not implemented yet")
    @missing_feature(library="java", reason="not implemented yet")
    @missing_feature(library="nodejs", reason="not implemented yet")
    @sql_irrelevant(condition=lambda test_sql_operation: test_sql_operation in ["select_error", "procedure"])
    @pytest.mark.usefixtures("manage_sql_decorators")
    def test_db_statement_query(self, test_sql_service, test_sql_operation, weblog_request):
        """ Usually the query """
        span_tracer, span_agent = self.get_spans(weblog_request)
        self._assert_span_meta(span_tracer, span_agent, "db.statement", test_sql_operation.upper())

    @missing_feature(library="nodejs", reason="not implemented yet")
    @missing_feature(library="python", reason="not implemented yet")
    @sql_irrelevant(condition=lambda test_sql_operation: test_sql_operation in ["select_error", "procedure"])
    @pytest.mark.usefixtures("manage_sql_decorators")
    def test_db_operation(self, test_sql_service, test_sql_operation, weblog_request):
        """ The name of the operation being executed """
        span_tracer, span_agent = self.get_spans(weblog_request)
        assert all(
            test_sql_operation.lower() in span_db
            for span_db in [span_tracer["meta"]["db.operation"].lower(), span_agent["meta"]["db.operation"].lower()]
        ), f"Expected db.instance [{test_sql_operation.lower()}] but found tracer[{span_tracer['meta']['db.operation']}] and agent[{span_agent['meta']['db.operation']}] "

    @missing_feature(library="nodejs", reason="not implemented yet")
    @missing_feature(library="python", reason="not implemented yet")
    @sql_irrelevant(condition=lambda test_sql_operation: test_sql_operation != "procedure")
    @pytest.mark.usefixtures("manage_sql_decorators")
    def test_db_operation_for_procedure(self, test_sql_service, test_sql_operation, weblog_request):
        """ The name of the operation being executed """
        span_tracer, span_agent = self.get_spans(weblog_request)
        assert any(
            substring in span_tracer["meta"]["db.operation"].lower() for substring in ["call", "exec"]
        ), "db.operation span not found for procedure operation"
        assert any(
            substring in span_agent["meta"]["db.operation"].lower() for substring in ["call", "exec"]
        ), "db.operation span not found for procedure operation"

    @missing_feature(library="python", reason="not implemented yet")
    @missing_feature(library="java", reason="not implemented yet")
    @missing_feature(library="nodejs", reason="not implemented yet")
    @sql_irrelevant(condition=lambda test_sql_operation: test_sql_operation == "procedure")
    @pytest.mark.usefixtures("manage_sql_decorators")
    def db_sql_table(self, test_sql_service, test_sql_operation, weblog_request):
        """ The name of the primary table that the operation is acting upon, including the database name (if applicable). """
        span_tracer, span_agent = self.get_spans(weblog_request)
        assert span_tracer["meta"]["db.sql.table"].strip()
        assert span_agent["meta"]["db.sql.table"].strip()

    @missing_feature(library="python", reason="not implemented yet")
    @missing_feature(library="nodejs", reason="not implemented yet")
    @missing_feature(library="java", reason="not implemented yet")
    @sql_irrelevant(condition=lambda test_sql_operation: test_sql_operation != "select")
    @pytest.mark.usefixtures("manage_sql_decorators")
    def test_db_row_count(self, test_sql_service, test_sql_operation, weblog_request):
        """ The number of rows/results from the query or operation. For caches and other datastores. 
        This tag should only set for operations that retrieve stored data, such as GET operations and queries, excluding SET and other commands not returning data.  """
        span_tracer, span_agent = self.get_spans(weblog_request)
        assert span_tracer["meta"]["db.row_count"] > 0
        assert span_agent["meta"]["db.row_count"] > 0

    def test_db_password(self, test_sql_service, test_sql_operation, weblog_request):
        """ The database password should not show in the traces """
        db_container = context.scenario.get_container_by_dd_integration_name(test_sql_service)
        span_tracer, span_agent = self.get_spans(weblog_request)
        for span in [span_tracer, span_agent]:
            for key in span["meta"]:
                if key not in [
                    "peer.hostname",
                    "db.user",
                    "env",
                    "db.instance",
                    "out.host",
                    "db.name",
                    "peer.service",
                    "net.peer.name",
                ]:  # These fields hostname, user... are the same as password
                    assert span["meta"][key] != db_container.db_password

    @missing_feature(condition=context.library != "java", reason="Apply only java")
    @missing_feature(library="java", reason="Not implemented yet")
    def test_db_jdbc_drive_classname(self, test_sql_service, test_sql_operation, weblog_request):
        """ The fully-qualified class name of the Java Database Connectivity (JDBC) driver used to connect. """
        span_tracer, span_agent = self.get_spans(weblog_request)
        assert span_tracer["meta"]["db.jdbc.driver_classname"].strip()
        assert span_agent["meta"]["db.jdbc.driver_classname"].strip()

    @sql_irrelevant(condition=lambda test_sql_operation: test_sql_operation != "select_error")
    @pytest.mark.usefixtures("manage_sql_decorators")
    def test_error_message(self, test_sql_service, test_sql_operation, weblog_request):
        for span in self.get_spans(weblog_request):
            # A string representing the error message.
            assert span["meta"]["error.message"].strip()

            # A string representing the type of the error.
            assert span["meta"]["error.type"].strip()

            # A human readable version of the stack trace.
            assert span["meta"]["error.stack"].strip()

    @irrelevant(
        library="java",
        reason="The Java tracer normalizing the SQL by replacing literals to reduce resource-name cardinality",
    )
    @pytest.mark.usefixtures("manage_sql_decorators")
    def test_tracer_NOT_obfuscate_query(self, test_sql_service, test_sql_operation, weblog_request):
        """ All queries come out without obfuscation from tracer library """
        span_tracer = self.get_span_from_tracer(weblog_request)
        assert span_tracer["resource"].count("?") == 0

    @sql_irrelevant(condition=lambda test_sql_operation: test_sql_operation in ["select_error", "procedure"])
    @pytest.mark.usefixtures("manage_sql_decorators")
    def test_sql_query(self, test_sql_service, test_sql_operation, weblog_request):
        """ Usually the query """
        span_agent = self.get_span_from_agent(weblog_request)
        assert (
            test_sql_operation in span_agent["meta"]["sql.query"].lower()
        ), f"sql.query span not found for operation {test_sql_operation}"

    @sql_irrelevant(condition=lambda test_sql_service: test_sql_service == "mssql")
    @pytest.mark.usefixtures("manage_sql_decorators")
    def test_obfuscate_query(self, test_sql_service, test_sql_operation, weblog_request):
        """ All queries come out obfuscated from agent """
        span_agent = self.get_span_from_agent(weblog_request)

        # We launch all queries with two parameters (from weblog)
        # Insert and procedure:These operations also receive two parameters, but are obfuscated as only one.
        if test_sql_operation in ["insert", "procedure"]:
            assert (
                span_agent["meta"]["sql.query"].count("?") == 1
            ), f"The query is not properly obfuscated for operation {test_sql_operation}"
        else:
            assert (
                span_agent["meta"]["sql.query"].count("?") == 2
            ), f"The query is not properly obfuscated for operation {test_sql_operation}"

    @sql_irrelevant(condition=lambda test_sql_service: test_sql_service != "mssql")
    @pytest.mark.usefixtures("manage_sql_decorators")
    def test_obfuscate_mmsql_query(self, test_sql_service, test_sql_operation, weblog_request):
        """ All queries come out obfuscated from agent """
        span_agent = self.get_span_from_agent(weblog_request)

        # We launch all queries with two parameters (from weblog)
        if test_sql_operation == "insert":
            expected_obfuscation_count = 1
        elif test_sql_operation == "procedure":
            # Insert and procedure:These operations also receive two parameters, but are obfuscated as only one.
            # Nodejs: The proccedure has a input parameter, but we are calling through method `execute`` and we can't see the parameters in the traces
            expected_obfuscation_count = 0 if context.library.library == "nodejs" else 2
        else:
            expected_obfuscation_count = 2

        observed_obfuscation_count = span_agent["meta"]["sql.query"].count("?")
        assert (
            observed_obfuscation_count == expected_obfuscation_count
        ), f"The mssql query fails. Expecting {expected_obfuscation_count} obfuscation(s), found {observed_obfuscation_count}:\n {span_agent['meta']['sql.query']}"

    @missing_feature(library="python", reason="Not implemented yet")
    @missing_feature(library="java", reason="Not implemented yet")
    @missing_feature(library="nodejs", reason="Not implemented yet")
    def test_db_mssql_instance_name(self, test_sql_service, test_sql_operation, weblog_request):
        """ The Microsoft SQL Server instance name connecting to. This name is used to determine the port of a named instance. 
            This value should be set only if it’s specified on the mssql connection string. """

        span_tracer, span_agent = self.get_spans(weblog_request)
        assert span_tracer["meta"]["db.mssql.instance_name"].strip()
        assert span_agent["meta"]["db.mssql.instance_name"].strip()

    def _assert_span_meta(self, span_tracer, span_agent, meta_tag, expected_value):
        assert all(
            expected_value.casefold() in span_db
            for span_db in [span_tracer["meta"][meta_tag].casefold(), span_agent["meta"][meta_tag].casefold()]
        ), f"Expected db.instance [{expected_value}] but found tracer[{span_tracer['meta'][meta_tag]}] and agent[{span_agent['meta'][meta_tag]}] "
