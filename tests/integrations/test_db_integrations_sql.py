# Unless explicitly stated otherwise all files in this repository are licensed under the the Apache License Version 2.0.
# This product includes software developed at Datadog (https://www.datadoghq.com/).
# Copyright 2021 Datadog, Inc.

from utils import context, interfaces, scenarios, features, logger
from utils.dd_constants import TraceAgentPayloadFormat

from .utils import BaseDbIntegrationsTestClass


class _BaseDatadogDbIntegrationTestClass(BaseDbIntegrationsTestClass):
    """Verify basic DB operations over different databases.
    Check integration spans status: https://docs.google.com/spreadsheets/d/1qm3B0tJ-gG11j_MHoEd9iMXf4_DvWAGCLwmBhWCxbA8/edit#gid=623219645
    """

    def get_spans(self, excluded_operations: tuple[str, ...] = (), operations: list[str] | None = None):
        """Get the spans from tracer and agent generated by all requests"""

        # yield the span from the tracer in first, as if it fails, there is a good chance that the one from the agent also fails
        for db_operation, request in self.get_requests(excluded_operations, operations=operations):
            logger.debug(f"Start validation for {self.db_service}/{db_operation}")

            logger.debug("Validating span generated by Datadog library")
            yield db_operation, (self.get_span_from_tracer(request), TraceAgentPayloadFormat.legacy)

            logger.debug("Validating transmitted by Datadog agent")
            yield db_operation, self.get_span_from_agent(request)

    # Tests methods
    def test_sql_traces(self, excluded_operations: tuple[str, ...] = ()):
        """After make the requests we check that we are producing sql traces"""
        for _, (span, _span_format) in self.get_spans(excluded_operations):
            assert span is not None

    def test_resource(self):
        """Usually the query"""

        for db_operation, (span, span_format) in self.get_spans(excluded_operations=("procedure", "select_error")):
            span_resource = interfaces.agent.get_span_resource(span, span_format)
            assert db_operation in span_resource.lower()

    def test_sql_success(self, excluded_operations: tuple[str, ...] = ()):
        """We check all sql launched for the app work"""

        for db_operation, (span, span_format) in self.get_spans(
            excluded_operations=excluded_operations + ("select_error",)
        ):
            if "error" in span and span["error"] != 0:
                span_meta = interfaces.agent.get_span_meta(span, span_format)
                logger.error(f"Error message: {span_meta.get('error.message')}")
                logger.error(f"Error stack:\n{span_meta.get('error.stack')}")

                raise ValueError(f"Error found in {db_operation} operation, please check captured log call")

    def test_db_type(self, excluded_operations: tuple[str, ...] = ()):
        """DEPRECATED!! Now it is db.system. An identifier for the database management system (DBMS) product being used.
        Must be one of the available values: https://datadoghq.atlassian.net/wiki/spaces/APM/pages/2357395856/Span+attributes#db.system
        """

        for db_operation, (span, span_format) in self.get_spans(excluded_operations=excluded_operations):
            span_meta = interfaces.agent.get_span_meta(span, span_format)
            assert span_meta["db.type"] == self.db_service, f"Test is failing for {db_operation}"

    def test_db_name(self):
        """DEPRECATED!! Now it is db.instance. The name of the database being connected to. Database instance name."""
        db_container = context.get_container_by_dd_integration_name(self.db_service)

        for db_operation, (span, span_format) in self.get_spans():
            span_meta = interfaces.agent.get_span_meta(span, span_format)
            assert span_meta["db.name"] == db_container.db_instance, f"Test is failing for {db_operation}"

    def test_span_kind(self, excluded_operations: tuple[str, ...] = ()):
        """Describes the relationship between the Span, its parents, and its children in a Trace."""

        for _, (span, span_format) in self.get_spans(excluded_operations):
            span_meta = interfaces.agent.get_span_meta(span, span_format)
            assert span_meta["span.kind"] == "client"

    def test_runtime_id(self):
        """Unique identifier for the current process."""

        for db_operation, (span, span_format) in self.get_spans():
            span_meta = interfaces.agent.get_span_meta(span, span_format)
            assert span_meta["runtime-id"].strip(), f"Test is failing for {db_operation}"

    def test_db_system(self):
        """An identifier for the database management system (DBMS) product being used. Formerly db.type
        Must be one of the available values: https://datadoghq.atlassian.net/wiki/spaces/APM/pages/2357395856/Span+attributes#db.system
        """

        for db_operation, (span, span_format) in self.get_spans():
            span_meta = interfaces.agent.get_span_meta(span, span_format)
            assert span_meta["db.system"] == self.db_service, f"Test is failing for {db_operation}"

    def test_db_connection_string(self):
        """The connection string used to connect to the database."""

        for db_operation, (span, span_format) in self.get_spans():
            span_meta = interfaces.agent.get_span_meta(span, span_format)
            assert span_meta["db.connection_string"].strip(), f"Test is failing for {db_operation}"

    def test_db_user(self, excluded_operations: tuple[str, ...] = ()):
        """Username for accessing the database."""
        db_container = context.get_container_by_dd_integration_name(self.db_service)

        for _, (span, span_format) in self.get_spans(excluded_operations=excluded_operations):
            span_meta = interfaces.agent.get_span_meta(span, span_format)
            assert span_meta["db.user"].casefold() == db_container.db_user.casefold()

    def test_db_instance(self, excluded_operations: tuple[str, ...] = ()):
        """The name of the database being connected to. Database instance name. Formerly db.name"""
        db_container = context.get_container_by_dd_integration_name(self.db_service)

        for _, (span, span_format) in self.get_spans(excluded_operations=excluded_operations):
            span_meta = interfaces.agent.get_span_meta(span, span_format)
            assert span_meta["db.instance"] == db_container.db_instance

    def test_db_statement_query(self):
        """Usually the query"""

        for db_operation, (span, span_format) in self.get_spans(excluded_operations=("procedure", "select_error")):
            span_meta = interfaces.agent.get_span_meta(span, span_format)
            assert db_operation in span_meta["db.statement"].lower()

    def test_db_operation(self, excluded_operations: tuple[str, ...] = ()):
        """The name of the operation being executed"""

        for db_operation, (span, span_format) in self.get_spans(
            excluded_operations=excluded_operations + ("select_error",)
        ):
            span_meta = interfaces.agent.get_span_meta(span, span_format)
            if db_operation == "procedure":
                assert any(substring in span_meta["db.operation"].lower() for substring in ["call", "exec"]), (
                    "db.operation span not found for procedure operation"
                )
            else:
                assert db_operation.lower() in span_meta["db.operation"].lower(), f"Test is failing for {db_operation}"

    def test_db_sql_table(self):
        """The name of the primary table that the operation is acting upon, including the database name (if applicable)."""

        for db_operation, (span, span_format) in self.get_spans(excluded_operations=("procedure",)):
            span_meta = interfaces.agent.get_span_meta(span, span_format)
            assert span_meta["db.sql.table"].strip(), f"Test is failing for {db_operation}"

    def test_db_row_count(self):
        """The number of rows/results from the query or operation. For caches and other datastores.
        This tag should only set for operations that retrieve stored data, such as GET operations and queries, excluding SET and other commands not returning data.
        """

        for _, (span, span_format) in self.get_spans(operations=["select"]):
            span_meta = interfaces.agent.get_span_meta(span, span_format)
            assert int(span_meta["db.row_count"]) > 0, "Test is failing for select"

    def test_db_password(self, excluded_operations: tuple[str, ...] = ()):
        """The database password should not show in the traces"""
        db_container = context.get_container_by_dd_integration_name(self.db_service)

        for db_operation, (span, span_format) in self.get_spans(excluded_operations=excluded_operations):
            span_meta = interfaces.agent.get_span_meta(span, span_format)
            for key in span_meta:
                if key not in [
                    "peer.hostname",
                    "db.user",
                    "env",
                    "db.instance",
                    "out.host",
                    "db.name",
                    "peer.service",
                    "net.peer.name",
                    "server.address",
                ]:  # These fields hostname, user... are the same as password
                    assert span_meta[key] != db_container.db_password, f"Test is failing for {db_operation}"

    def test_db_jdbc_drive_classname(self):
        """The fully-qualified class name of the Java Database Connectivity (JDBC) driver used to connect."""

        for db_operation, (span, span_format) in self.get_spans():
            span_meta = interfaces.agent.get_span_meta(span, span_format)
            assert span_meta["db.jdbc.driver_classname"].strip(), f"Test is failing for {db_operation}"

    def test_error_message(self):
        for _, (span, span_format) in self.get_spans(operations=["select_error"]):
            span_meta = interfaces.agent.get_span_meta(span, span_format)
            # A string representing the error message.
            assert span_meta["error.message"].strip()

            # A string representing the type of the error.
            assert span_meta["error.type"].strip()

            # A human readable version of the stack trace.
            assert span_meta["error.stack"].strip()

    def test_not_obfuscate_query(self):
        """All queries come out without obfuscation from tracer library"""
        for db_operation, request in self.get_requests():
            span = self.get_span_from_tracer(request)
            assert span["resource"].count("?") == 0, f"The query should not be obfuscated for operation {db_operation}"

    def test_sql_query(self):
        """Usually the query"""
        for db_operation, request in self.get_requests(excluded_operations=["procedure", "select_error"]):
            span, span_format = self.get_span_from_agent(request)
            span_meta = interfaces.agent.get_span_meta(span, span_format)
            assert db_operation in span_meta["sql.query"].lower(), (
                f"sql.query span not found for operation {db_operation}"
            )

    def test_obfuscate_query(self):
        """All queries come out obfuscated from agent"""
        for db_operation, request in self.get_requests():
            span, span_format = self.get_span_from_agent(request)
            span_meta = interfaces.agent.get_span_meta(span, span_format)
            # We launch all queries with two parameters (from weblog)
            # Insert and procedure:These operations also receive two parameters, but are obfuscated as only one.
            if db_operation in ["insert", "procedure"]:
                assert span_meta["sql.query"].count("?") == 1, (
                    f"The query is not properly obfuscated for operation {db_operation}"
                )
            else:
                assert span_meta["sql.query"].count("?") == 2, (
                    f"The query is not properly obfuscated for operation {db_operation}"
                )


@features.postgres_support
@scenarios.integrations
class Test_Postgres(_BaseDatadogDbIntegrationTestClass):
    """Postgres integration with Datadog tracer+agent"""

    db_service = "postgresql"

    def test_db_type(self, excluded_operations: tuple[str, ...] = ()):  # noqa: ARG002, PT028
        super().test_db_type()


@features.mysql_support
@scenarios.integrations
class Test_MySql(_BaseDatadogDbIntegrationTestClass):
    """MySql integration with Datadog tracer+agent"""

    db_service = "mysql"

    def test_db_name(self):
        super().test_db_name()

    def test_db_user(self, excluded_operations: tuple[str, ...] = ()):  # noqa: ARG002, PT028
        super().test_db_user()


@features.mssql_support
@scenarios.integrations
class Test_MsSql(_BaseDatadogDbIntegrationTestClass):
    """MsSql integration with Datadog tracer+agent"""

    db_service = "mssql"

    def test_db_mssql_instance_name(self):
        """The Microsoft SQL Server instance name connecting to. This name is used to determine the port of a named instance.
        This value should be set only if it's specified on the mssql connection string.
        """

        for db_operation, span in self.get_spans():
            assert span["meta"]["db.mssql.instance_name"].strip(), (
                f"db.mssql.instance_name must not be empty for operation {db_operation}"
            )

    def test_db_name(self):
        super().test_db_name()

    def test_db_system(self):
        super().test_db_system()

    def test_db_user(self, excluded_operations: tuple[str, ...] = ()):  # noqa: ARG002, PT028
        super().test_db_user()

    def test_obfuscate_query(self):
        """All queries come out obfuscated from agent"""
        for db_operation, request in self.get_requests():
            span, span_format = self.get_span_from_agent(request)
            span_meta = interfaces.agent.get_span_meta(span, span_format)
            # We launch all queries with two parameters (from weblog)
            if db_operation == "insert":
                expected_obfuscation_count = 1
            elif db_operation == "procedure":
                # Insert and procedure:These operations also receive two parameters, but are obfuscated as only one.
                # Node.js: The proccedure has a input parameter, but we are calling through method `execute`` and we can't see the parameters in the traces
                expected_obfuscation_count = 0 if context.library.name == "nodejs" else 2
            else:
                expected_obfuscation_count = 2

            observed_obfuscation_count = span_meta["sql.query"].count("?")
            assert observed_obfuscation_count == expected_obfuscation_count, (
                f"The mssql query is not properly obfuscated for operation {db_operation}, expecting {expected_obfuscation_count} obfuscation(s), found {observed_obfuscation_count}:\n {span_meta['sql.query']}"
            )

    def test_sql_success(self, excluded_operations: tuple[str, ...] = ()):  # noqa: ARG002, PT028
        super().test_sql_success()
