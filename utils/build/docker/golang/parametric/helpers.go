// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.28.1
// 	protoc        v4.25.3
// source: apm_test_client.proto

package main

import (
	"encoding/json"
	"fmt"
	"go.opentelemetry.io/otel/attribute"
)

type GetTraceConfigReturn struct {
	Config map[string]string `json:"config"`
}

type StartSpanArgs struct {
	Name        string                  `json:"name,omitempty"`
	Service     string                 `json:"service,omitempty"`
	ParentId    uint64                 `json:"parent_id,omitempty"`
	Resource    string                 `json:"resource,omitempty"`
	Type        string                 `json:"type,omitempty"`
	Origin      string                 `json:"origin,omitempty"`
	HttpHeaders []HeaderTuple `json:"http_headers,omitempty"`
	SpanTags    []TagTuple          `json:"span_tags,omitempty"`
	SpanLinks   []*SpanLink             `json:"span_links,omitempty"`
}

type TagTuple []string

func (x TagTuple) Key() string {
	if x != nil {
		return x[0]
	}
	return ""
}

func (x TagTuple) Value() string {
	if x != nil {
		return x[1]
	}
	return ""
}

type DistributedHTTPHeaders [][]string

type SpanLink struct {
	// Types that are assignable to From:
	//
	//	*SpanLink_ParentId
	//	*SpanLink_HttpHeaders
	ParentId   *uint64 `json:"parent_id"`
	HttpHeaders []HeaderTuple `json:"http_headers"`
	Attributes AttributeKeyVals     `json:"attributes,omitempty"`
}

func (x *SpanLink) GetAttributes() AttributeKeyVals {
	if x != nil {
		return x.Attributes
	}
	return nil
}

type isSpanLink_From interface {
	isSpanLink_From()
}

type SpanLink_ParentId struct {
	ParentId uint64 `protobuf:"varint,1,opt,name=parent_id,json=parentId,proto3,oneof"`
}

type SpanLink_HttpHeaders struct {
	HttpHeaders *[]HeaderTuple `protobuf:"bytes,2,opt,name=http_headers,json=httpHeaders,proto3,oneof"`
}

func (*SpanLink_ParentId) isSpanLink_From() {}

func (*SpanLink_HttpHeaders) isSpanLink_From() {}

type HeaderTuple struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

func (x *HeaderTuple) GetKey() string {
	if x != nil {
		return x.Key
	}
	return ""
}

func (x *HeaderTuple) GetValue() string {
	if x != nil {
		return x.Value
	}
	return ""
}

type StartSpanReturn struct {
	SpanId  uint64 `json:"span_id"`
	TraceId uint64 `json:"trace_id"`
}

type InjectHeadersArgs struct {
	SpanId uint64 `json:"span_id"`
}

type InjectHeadersReturn struct {
	HttpHeaders DistributedHTTPHeaders `json:"http_headers"`
}

type FinishSpanArgs struct {
	Id uint64 `json:"span_id"`
}

type SpanSetMetaArgs struct {
	SpanId uint64 `json:"span_id"`
	Key    string `json:"key"`
	Value  string `json:"value"`
}

type SpanSetMetricArgs struct {
	SpanId uint64  `json:"span_id"`
	Key    string  `json:"key"`
	Value  float32 `json:"value"`
}
type SpanSetErrorArgs struct {
	SpanId  uint64  `json:"span_id"`
	Type    *string `json:"type"`
	Message *string `json:"message"`
	Stack   *string `json:"stack"`
}

type OtelStartSpanArgs struct {
	Name        string                  `json:"name"`
	ParentId    uint64                 `json:"parent_id"`
	SpanKind    uint64                 `json:"span_kind"`
	Service     string                 `json:"service"`
	Resource    string                 `json:"resource"`
	Type        string                 `json:"type"`
	Timestamp   int64                  `json:"timestamp"`
	SpanLinks   []SpanLink             `json:"links"`
	HttpHeaders []HeaderTuple `json:"http_headers"`
	Attributes  AttributeKeyVals             `json:"attributes"`
}

type OtelStartSpanReturn struct {
	SpanId  uint64 `json:"span_id"`
	TraceId uint64 `json:"trace_id"`
}

type OtelEndSpanArgs struct {
	Id        uint64 `json:"id"`
	Timestamp *int64 `json:"timestamp,omitempty"`
}

func (x *OtelEndSpanArgs) GetTimestamp() int64 {
	if x != nil && x.Timestamp != nil {
		return *x.Timestamp
	}
	return 0
}

type OtelFlushSpansArgs struct {
	Seconds uint32 `json:"seconds"`
}

type OtelFlushSpansReturn struct {
	Success bool `json:"success"`
}

type OtelIsRecordingArgs struct {
	SpanId uint64 `json:"span_id"`
}

type OtelIsRecordingReturn struct {
	IsRecording bool `json:"is_recording"`
}

type OtelSpanContextArgs struct {
	SpanId uint64 `json:"span_id,omitempty"`
}

type OtelSpanContextReturn struct {
	SpanId     string `json:"span_id"`
	TraceId    string `json:"trace_id"`
	TraceFlags string `json:"trace_flags"`
	TraceState string `json:"trace_state"`
	Remote     bool   `json:"remote"`
}

type OtelSetStatusArgs struct {
	SpanId      uint64 `json:"span_id"`
	Code        string `json:"code"`
	Description string `json:"description"`
}

type OtelSetNameArgs struct {
	SpanId uint64 `json:"span_id"`
	Name   string `json:"name"`
}

type OtelSetAttributesArgs struct {
	SpanId     uint64      `json:"span_id"`
	Attributes *AttributeKeyVals `json:"attributes"`
}

type OtelAddEventArgs struct {
	SpanId     uint64      `json:"span_id"`
	Name       string      `json:"name"`
	Timestamp  *int64      `json:"timestamp"`
	Attributes *AttributeKeyVals `json:"attributes"`
}

func (x *OtelAddEventArgs) GetTimestamp() int64 {
	if x != nil && x.Timestamp != nil {
		return *x.Timestamp
	}
	return 0
}

func (x *OtelAddEventArgs) GetAttributes() *AttributeKeyVals {
	if x != nil {
		return x.Attributes
	}
	return nil
}

type AttributeKeyVals map[string]interface{}

func (a AttributeKeyVals) ConvertToAttributes() []attribute.KeyValue {
	var attrs []attribute.KeyValue
	for k, v := range a {
		switch t := v.(type) {
		case bool:
			attrs = append(attrs, attribute.Bool(k, v.(bool)))
		case float64:
			attrs = append(attrs, attribute.Float64(k, v.(float64)))
		case int:
			attrs = append(attrs, attribute.Int(k, v.(int)))
		case int64:
			attrs = append(attrs, attribute.Int64(k, t))
		case string:
			attrs = append(attrs, attribute.String(k, v.(string)))
		case []interface{}:
			if len(t) > 0 {
				switch tt := t[0].(type) {
				case bool:
					len := len(t)
					boolSlice := make([]bool, len)
					boolSlice[0] = tt
					for i := 1; i < len; i++ {
						boolSlice[i] = t[i].(bool)
					}
					attrs = append(attrs, attribute.BoolSlice(k, boolSlice))
				case float64:
					len := len(t)
					floatSlice := make([]float64, len)
					floatSlice[0] = tt
					for i := 1; i < len; i++ {
						floatSlice[i] = t[i].(float64)
					}
					attrs = append(attrs, attribute.Float64Slice(k, floatSlice))
				case int:
					len := len(t)
					intSlice := make([]int, len)
					intSlice[0] = tt
					for i := 1; i < len; i++ {
						intSlice[i] = t[i].(int)
					}
					attrs = append(attrs, attribute.IntSlice(k, intSlice))
				case int64:
					len := len(t)
					int64Slice := make([]int64, len)
					int64Slice[0] = tt
					for i := 1; i < len; i++ {
						int64Slice[i] = t[i].(int64)
					}
					attrs = append(attrs, attribute.Int64Slice(k, int64Slice))
				case string:
					len := len(t)
					stringSlice := make([]string, len)
					stringSlice[0] = tt
					for i := 1; i < len; i++ {
						stringSlice[i] = t[i].(string)
					}
					attrs = append(attrs, attribute.StringSlice(k, stringSlice))
				default:
					fmt.Printf("Attribute %v has unsupported type%T; dropping\n", k, v)
				}
			}
		default:
			fmt.Printf("Attribute %v has unsupported type%T; dropping\n", k, v)
		}
	}
	return attrs
}

func (a AttributeKeyVals) ConvertToAttributesStringified() []attribute.KeyValue {
	var attrs []attribute.KeyValue
	for k, v := range a {
		s, err := json.Marshal(v)
		if err != nil {
			fmt.Printf("Error converting attribute to json string: %v\n", err.Error())
		}
		attrs = append(attrs, attribute.String(k, string(s)))
	}
	return attrs
}
