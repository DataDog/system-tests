syntax = "proto3";
package proto_message;

message AddressBook {
  map<int32, Person> people = 1; // checks that the types generated by the usage of a map are correctly handled
  PhoneNumber central = 2; // here to check that we don't re-extract the PhoneNumber message when we encounter it again

  // now just put every type to be exhaustive
  // to help debugging a bit, the number given is the enum value of the type + 10
  double my_double = 11;
  float my_float = 12;
  int64 my_int64 = 13;
  uint64 my_uint64 = 14;
  int32 my_int32 = 15;
  fixed64 my_fixed64 = 16;
  fixed32 my_fixed32 = 17;
  bool my_bool = 18;
  string my_string = 19;
  bytes my_bytes = 22;
  uint32 my_uint32 = 23;
  sfixed32 my_sfixed32 = 25;
  sfixed64 my_sfixed64 = 26;
  sint32 my_sint32 = 27;
  sint64 my_sint64 = 28;
}

message PhoneNumber {
  string number = 1;
  PhoneType type = 2; // check that enum are handled properly
}

enum PhoneType {
  UNSPECIFIED = 0;
  MOBILE = 1;
  HOME = 2;
  WORK = 3;
}

message Person {
  string name = 1;
  repeated PhoneNumber phones = 4; // check repeated fields
  uint64 created = 5;
  double last_updated = 6;

  // this one is very artificial, but it's here to check that we stop at the same depth for all tracers
  RecursiveField recurse = 7;

  message RecursiveField {
    sint32 value = 1;
    RecursiveField deeper = 2;
  }
}

message Deep {
  A x = 1;

  message A{
    B x = 1;
  }

  message B{
    C x = 1;
  }

  message C{
    D x = 1;
  }

  message D{
    E x = 1;
  }

  message E{
    F x = 1;
  }

  message F{
    G x = 1;
  }

  message G{
    H x = 1;
  }

  message H{
    I x = 1;
  }

  message I{
    J x = 1;
  }

  message J{
    K x = 1;
  }

  message K{
    int32 x = 1;
  }
}
