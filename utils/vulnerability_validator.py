import traceback
import json
from collections import namedtuple
from collections import Counter


class VulnerabilityValidator:
    """Validate iast reported vulnerabilities"""

    def __init__(self):
        self.vulnerability_filter = VulnerabilityValidator._VulnerabilityFilter()

    def expect_exact_count(self, count):
        self.vulnerability_filter.setCounter(VulnerabilityValidator.VulnerabilityCounter(count_exact=True, count=count))
        return self.vulnerability_filter

    def expect_at_least_count(self, count):
        self.vulnerability_filter.setCounter(VulnerabilityValidator.VulnerabilityCounter(count=count, least_count=True))
        return self.vulnerability_filter

    def expect_any_match(self):
        self.vulnerability_filter.setCounter(VulnerabilityValidator.VulnerabilityCounter(any_match=True))
        return self.vulnerability_filter

    def expect_only_these_vulnerabilities(self, count=None):
        self.vulnerability_filter.setCounter(
            VulnerabilityValidator.VulnerabilityCounter(count_exact=True, count=count, only_these_vulnerabilities=True)
        )
        return self.vulnerability_filter

    class _VulnerabilityFilter:
        """Filter vulnerabilities as tester (user) defined"""

        def __init__(self):
            self.vulnerability = None
            self.vulnerability_counter = None

        def with_data(self, vulnerability):
            self.vulnerability = vulnerability
            return self

        def setCounter(self, vulnerability_counter):
            self.vulnerability_counter = vulnerability_counter

        def __get_vulnerability_filters(self):
            filters = []
            if not self.vulnerability:
                return filters
            if self.vulnerability.type:
                filters.append(lambda vul: vul.type == self.vulnerability.type)

            if self.vulnerability.evidence_value:
                filters.append(lambda vul: vul.evidence.value == self.vulnerability.evidence_value)

            if self.vulnerability.location_path:
                filters.append(lambda vul: vul.location.path == self.vulnerability.location_path)
                if self.vulnerability.location_line:
                    filters.append(lambda vul: vul.location.line == self.vulnerability.location_line)
            return filters

        def __str_vulnerabilties(self, vulnerabilities):
            return f" \n vulnerabilities_count:" + str(len(vulnerabilities)) + ", " + json.dumps(vulnerabilities)

        def validate(self, vulnerabilities):
            filters = self.__get_vulnerability_filters()
            filteredVulnerabilities = list(filter(lambda x: all(f(x) for f in filters), vulnerabilities))

            countTotal = len(vulnerabilities)
            countFiltered = len(filteredVulnerabilities)

            if self.vulnerability_counter.check_unexpected_vulnerability_counter(countTotal, countFiltered):

                raise Exception(
                    f"""Expected assertion failed:
    Expected counter:  {str(self.vulnerability_counter)} 
    Expected vulnerability filter: {str(self.vulnerability)} 
    Current all vulnerabilities: {self.__str_vulnerabilties(vulnerabilities)} 
    Current filtered vulnerabilitites: {self.__str_vulnerabilties(filteredVulnerabilities)}  """
                )
            return True

    class VulnerabilityCounter:
        """Vulnerability counter according to the defined condition"""

        def __init__(
            self, count_exact=False, least_count=False, any_match=False, only_these_vulnerabilities=False, count=1
        ):
            self.count_exact = count_exact
            self.least_count = least_count
            self.any_match = any_match
            self.only_these_vulnerabilities = only_these_vulnerabilities
            self.count = count

        def check_unexpected_vulnerability_counter(self, countTotal, countFiltered):
            return (
                self.__check_filter_only_these_vulnerabilities(countTotal, countFiltered)
                or self.__check_filter_any_match(countFiltered)
                or self.__check_filter_at_least(countFiltered)
                or self.__check_filter_exact_count(countFiltered)
            )

        def __check_filter_only_these_vulnerabilities(self, countTotal, countFiltered):
            return self.only_these_vulnerabilities and countTotal != countFiltered

        def __check_filter_any_match(self, countFiltered):
            return self.any_match and countFiltered == 0

        def __check_filter_at_least(self, countFiltered):
            return self.least_count and self.count > countFiltered

        def __check_filter_exact_count(self, countFiltered):
            if (
                not self.any_match
                and not self.least_count
                and (not self.only_these_vulnerabilities or (self.count and self.count_exact))
            ):
                return countFiltered != self.count
            return False

        def __str__(self):
            return f" \n [ Vul count:{self.count}, only_these_vulnerabilities:{self.only_these_vulnerabilities}, any_match:{self.any_match}, at_least_count:{self.least_count}]"


class Vulnerability:
    def __init__(
        self,
        type=None,
        location_path=None,
        location_line=None,
        evidence_value=None,
    ):
        self.type = type
        self.location_path = location_path
        self.location_line = location_line
        self.evidence_value = evidence_value

    def __str__(self):
        return f" \n [ type: {self.type}, evidence:{self.evidence_value}, location: {self.location_path}({self.location_line})]"
